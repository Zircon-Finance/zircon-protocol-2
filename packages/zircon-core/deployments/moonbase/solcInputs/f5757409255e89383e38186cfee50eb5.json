{
  "language": "Solidity",
  "sources": {
    "contracts/energy/ZirconEnergyRevenue.sol": {
      "content": "pragma solidity =0.5.16;\nimport \"./interfaces/IUniswapV2ERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"../interfaces/IZirconPair.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract ZirconEnergyRevenue is ReentrancyGuard  {\n    using SafeMath for uint112;\n    using SafeMath for uint256;\n\n    uint public reserve;\n    address public energyfactory;\n    struct Zircon {\n        address pairAddress;\n        address floatToken;\n        address anchorToken;\n        address energy0;\n        address energy1;\n        address pylon0;\n        address pylon1;\n    }\n    Zircon zircon;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Zircon Pylon: TRANSFER_FAILED');\n    }\n\n\n    modifier _onlyEnergy() {\n        require(msg.sender == zircon.energy0 || msg.sender == zircon.energy1, \"ZE: Not Pylon\");\n        _;\n    }\n    modifier _onlyPair() {\n        require(zircon.pairAddress == msg.sender, \"ZE: Not Pylon\");\n        _;\n    }\n\n    constructor() public {\n        energyfactory = msg.sender;\n    }\n\n    function initialize(address _pair, address _tokenA, address _tokenB, address energy0, address energy1, address pylon0, address pylon1) external {\n        require(energyfactory == msg.sender, \"ZER: Not properly called\");\n        bool isFloatToken0 = IZirconPair(_pair).token0() == _tokenA;\n        (address tokenA, address tokenB) = isFloatToken0 ? (_tokenA, _tokenB) : (_tokenA, _tokenB);\n        zircon = Zircon(\n        _pair,\n        tokenA,\n        tokenB,\n        energy0,\n        energy1,\n        pylon0,\n        pylon1\n        );\n\n    }\n\n    function calculate() external _onlyPair nonReentrant {\n        uint balance = IUniswapV2ERC20(zircon.pairAddress).balanceOf(address(this));\n        console.log(\"zer: Balance\", balance);\n        require(balance > reserve, \"ZER: Reverted\");\n\n        uint pylonBalance0 = IUniswapV2ERC20(zircon.pairAddress).balanceOf(zircon.pylon0);\n        uint pylonBalance1 = IUniswapV2ERC20(zircon.pairAddress).balanceOf(zircon.pylon1);\n        uint totalSupply = IUniswapV2ERC20(zircon.pairAddress).totalSupply();\n        uint amount = balance.sub(reserve);\n\n        uint pylon0Liq = amount.mul(pylonBalance0)/totalSupply;\n        uint pylon1Liq = amount.mul(pylonBalance1)/totalSupply;\n\n        console.log(\"zer::pylon0\", pylon0Liq, zircon.pylon0);\n        console.log(\"zer::pylon1\", pylon1Liq, zircon.pylon1);\n        console.log(\"zer::amount\", amount);\n\n        _safeTransfer(zircon.pairAddress, zircon.energy0, pylon0Liq);\n        _safeTransfer(zircon.pairAddress, zircon.energy1, pylon1Liq);\n//        uint balance2 = IUniswapV2ERC20(zircon.pairAddress).balanceOf(address(this));\n//        uint balance3 = IUniswapV2ERC20(zircon.pairAddress).balanceOf(zircon.energy0);\n//        uint balance4 = IUniswapV2ERC20(zircon.pairAddress).balanceOf(zircon.energy1);\n//        console.log(\"zer: Balance2\", balance2);\n//        console.log(\"zer: Balance3\", balance3);\n//        console.log(\"zer: Balance4\", balance4);\n\n        reserve = balance.sub(pylon0Liq.add(pylon1Liq));\n        console.log(\"zer::reserve\", reserve);\n    }\n\n}\n"
    },
    "contracts/energy/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/energy/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.5.16;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/interfaces/IZirconPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IZirconPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function energyRevenueAddress() external pure returns (address);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function burnOneSide(address to, bool isReserve0) external returns (uint amount);\n    function mintOneSide(address to, bool isReserve0) external returns (uint liquidity, uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function tryLock() external;\n\n    function initialize(address, address, address) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/ZirconPylon.sol": {
      "content": "pragma solidity ^0.5.16;\nimport './libraries/Math.sol';\nimport './interfaces/IZirconPair.sol';\nimport './interfaces/IZirconPoolToken.sol';\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./libraries/ZirconLibrary.sol\";\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IZirconPylonFactory.sol\";\nimport \"hardhat/console.sol\";\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"./interfaces/IZirconPylon.sol\";\nimport \"./energy/interfaces/IZirconEnergy.sol\";\nimport \"./energy/interfaces/IZirconEnergyRevenue.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract ZirconPylon is IZirconPylon, ReentrancyGuard {\n    // **** Libraries ****\n    using SafeMath for uint112;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    // **** STRUCTS *****\n    struct PylonToken {\n        address float;\n        address anchor;\n    }\n    PylonToken public pylonToken;\n\n    // ***** GLOBAL VARIABLES ******\n\n    // ***** The address of the other components ******\n    address public pairAddress;\n    address public factoryAddress;\n    address public pairFactoryAddress;\n    address public floatPoolTokenAddress;\n    address public anchorPoolTokenAddress;\n    address public energyAddress;\n\n    // Indicates if in the pair the token0 is float or anchor\n    bool public isFloatReserve0;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    bytes4 private constant SELECTOR_FROM = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n\n    // ***** Variables for calculations *****\n    uint public virtualAnchorBalance;\n    uint public virtualFloatBalance;\n    uint public maximumPercentageSync;\n    uint public dynamicFeePercentage;\n    uint public gammaMulDecimals; // Name represents the fact that this is always the numerator of a fraction with 10**18 as denominator.\n    uint public lastK;\n    uint public lastPoolTokens;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves (always anchor)\n    uint112 private reserve1;           // us es single storage slot, accessible via getReserves (always float)\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    // global variable used for testing\n    uint private testMultiplier = 1e16;\n\n    // **** MODIFIERS *****\n    uint public initialized = 0;\n    modifier isInitialized() {\n        require(initialized == 1, 'ZP: NOT INITIALIZED');\n        _;\n    }\n\n    // Calls dummy function with lock modifier\n    modifier pairUnlocked() {\n        IZirconPair(pairAddress).tryLock();\n        _;\n    }\n\n    modifier blockRecursion() {\n        // TODO: Should do some kind of block height check to ensure this user hasn't\n        // already called any of these functions\n        _;\n    }\n\n    // **** EVENTS ****\n    event PylonUpdate(uint _reserve0, uint _reserve1);\n    event PylonSync(uint _vab, uint _vfb, uint _gamma);\n\n    // Transform in just one event\n    event MintSync(address sender, uint aIn0, bool isAnchor);\n    event MintAsync(address sender, uint aIn0, uint aIn1);\n    event MintAsync100(address sender, uint aIn0, bool isAnchor);\n    event Burn(address sender, uint aIn0, bool isAnchor);\n    event BurnAsync(address sender, uint aIn0, uint aIn1);\n    event Excess(uint aIn0, bool isAnchor);\n\n    // ****** CONSTRUCTOR ******\n    constructor() public {\n        factoryAddress = msg.sender;\n    }\n\n    // ****** HELPER FUNCTIONS *****\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Zircon Pylon: TRANSFER_FAILED');\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR_FROM, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Zircon Pylon: TRANSFER_FROM_FAILED');\n    }\n\n    function getSyncReserves()  public view returns  (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /// @notice Private function to get pair reserves normalized on float and anchor\n    // @return _reserve0 -> float\n    // @return _reserve1 -> Anchor\n    function getPairReservesNormalized()  private view returns  (uint112 _reserve0, uint112 _reserve1) {\n        (uint112 _reservePair0, uint112 _reservePair1,) = IZirconPair(pairAddress).getReserves();\n        _reserve0 = isFloatReserve0 ? _reservePair0 : _reservePair1;\n        _reserve1 = isFloatReserve0 ? _reservePair1 : _reservePair0;\n    }\n\n    /// @notice Function that returns pair reserves translated to pylon\n    /// @return Float -> _reserve0\n    /// @dev Anchor -> _reserve1\n    function getPairReservesTranslated(uint error0, uint error1)  private view returns  (uint _reserve0, uint _reserve1) {\n        (uint112 _reservePair0, uint112 _reservePair1) = getPairReservesNormalized();\n        _reserve0 = translateToPylon(uint(_reservePair0), error0);\n        _reserve1 = translateToPylon(uint(_reservePair1), error1);\n    }\n\n    /// @notice Function to obtain Pair Reserves on Pylon Basis\n    /// In case PTT Or PTB are null it will @return errorReturn\n    function translateToPylon(uint toConvert, uint errorReturn) view private returns (uint amount){\n        uint ptb = IZirconPair(pairAddress).balanceOf(address(this));\n        uint ptt = IZirconPair(pairAddress).totalSupply();\n        amount =  (ptt == 0 || ptb == 0) ? errorReturn : toConvert.mul(ptb)/ptt;\n    }\n\n\n    /// @notice Helper function to calculate slippage-adjusted share of pool\n    function _disincorporateAmount(uint _amountIn, bool isAnchor) private view returns (uint amount0, uint amount1) {\n        (uint112 _reservePair0, uint112 _reservePair1) = getPairReservesNormalized();\n        amount0 = !isAnchor ? _amountIn/2 : ZirconLibrary.getAmountOut(_amountIn/2, _reservePair1, _reservePair0);\n        amount1 = isAnchor ? _amountIn/2 : ZirconLibrary.getAmountOut(_amountIn/2, _reservePair0, _reservePair1);\n    }\n\n    function getLiquidityFromPoolTokens(uint amountIn0, uint amountIn1,  bool shouldMintAnchor, IZirconPoolToken pt) private view returns (uint liquidity, uint amountInAdjusted){\n        (uint112 _pairReserve0, uint112 _pairReserve1) = getPairReservesNormalized();\n        (uint112 _reserve0, uint112 _reserve1,) = getSyncReserves(); // gas savings\n\n        if (shouldMintAnchor) {\n            amountInAdjusted = Math.min((amountIn0.mul(_pairReserve1).mul(2))/_pairReserve0, amountIn1.mul(2)); //Adjust AmountIn0 to its value in Anchor tokens\n            liquidity = ZirconLibrary.calculatePTU(shouldMintAnchor, amountInAdjusted, pt.totalSupply(), translateToPylon(_pairReserve1, 0), _reserve1, gammaMulDecimals, virtualAnchorBalance);\n        }else{\n            amountInAdjusted = Math.min((amountIn1.mul(_pairReserve0).mul(2))/_pairReserve1, amountIn0.mul(2)); //Adjust AmountIn1 to its value in Float tokens\n            liquidity = ZirconLibrary.calculatePTU(shouldMintAnchor, amountInAdjusted, pt.totalSupply(), translateToPylon(_pairReserve0, 0), _reserve0, gammaMulDecimals, virtualAnchorBalance);\n        }\n    }\n\n    // ***** INIT ******\n\n    // @notice Called once by the factory at time of deployment\n    // @_floatPoolTokenAddress -> Contains Address Of Float PT\n    // @_anchorPoolTokenAddress -> Contains Address Of Anchor PT\n    // @floatToken -> Float token\n    // @anchorToken -> Anchor token\n    function initialize(address _floatPoolTokenAddress, address _anchorPoolTokenAddress, address _floatToken, address _anchorToken, address _pairAddress, address _pairFactoryAddress, address _energy) external nonReentrant {\n        require(msg.sender == factoryAddress, 'Zircon: FORBIDDEN'); // sufficient check\n        floatPoolTokenAddress = _floatPoolTokenAddress;\n        anchorPoolTokenAddress = _anchorPoolTokenAddress;\n        pairAddress = _pairAddress;\n        isFloatReserve0 = IZirconPair(_pairAddress).token0() == _floatToken;\n        pylonToken = PylonToken(_floatToken, _anchorToken);\n        pairFactoryAddress = _pairFactoryAddress;\n        energyAddress = _energy;\n\n        maximumPercentageSync = IZirconPylonFactory(factoryAddress).maximumPercentageSync();\n        dynamicFeePercentage = IZirconPylonFactory(factoryAddress).dynamicFeePercentage();\n\n    }\n\n    // @notice On init pylon we have to handle two cases\n    // The first case is when we initialize the pair through the pylon\n    // And the second one is when initialize the pylon with a pair already existing\n    function initPylon(address _to) external nonReentrant returns (uint floatLiquidity, uint anchorLiquidity) {\n        require(initialized == 0, \"Already Initialized\");\n\n        // Let's get the balances so we can see what the user send us\n        // As we are initializing the reserves are going to be null\n        uint balance0 = IERC20Uniswap(pylonToken.float).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(pylonToken.anchor).balanceOf(address(this));\n        require(balance0 > 0 && balance1 > 0, \"ZP: Not enough liquidity\");\n\n        // Let's see if the pair contains some reserves\n        (uint112 _reservePair0, uint112 _reservePair1) = getPairReservesNormalized();\n        // If pair contains reserves we have to use the ratio of the Pair so...\n\n        virtualFloatBalance = balance0.sub(balance0.mul(dynamicFeePercentage)/10000);\n        virtualAnchorBalance = balance1.sub(balance1.mul(dynamicFeePercentage)/10000);\n        if (_reservePair0 > 0 && _reservePair1 > 0) {\n            uint denominator = (virtualAnchorBalance.mul(_reservePair0))/_reservePair1;\n            gammaMulDecimals = (virtualFloatBalance*1e18) /  (virtualFloatBalance.add(denominator));\n            // This is gamma formula when FTV <= 50%\n        } else {\n            // When Pair is not initialized let's start gamma to 0.5\n            gammaMulDecimals = 500000000000000000;\n        }\n        // TODO: Old definition of gamma, necessary because pool may not be initialized but check for weird interactions\n        // Time to mint some tokens\n        (anchorLiquidity,) = _mintPoolToken(balance1, 0, _reservePair1, anchorPoolTokenAddress, _to, true);\n        (floatLiquidity,) = _mintPoolToken(balance0, 0, _reservePair0, floatPoolTokenAddress, _to, false);\n\n        //Here it updates the state and throws liquidity into the pool if possible\n        _update();\n        initialized = 1;\n    }\n\n\n    // ***** EXCESS RESERVES ******\n\n\n    // This function takes\n    // @balance0 & @balance1 -> The New Balances After A Sync Update\n    // @max0 & @max1 -> The maximum that we can save on the reserves\n    // If we have any excess reserves we donate them to the pool\n    //TODO:- Function should be fine although the mintOneSide usage could be dangerous\n    //TODO:- But we need to check how we use it.\n    function updateReservesRemovingExcess(uint newReserve0, uint newReserve1, uint112 max0, uint112 max1) private {\n        uint ptl = 0;\n        if (max0 < newReserve0) {\n            _safeTransfer(pylonToken.float, pairAddress, newReserve0.sub(max0));\n            (ptl,,) = IZirconPair(pairAddress).mintOneSide(address(this), isFloatReserve0);\n            reserve0 = max0;\n        } else {\n            reserve0 = uint112(newReserve0);\n        }\n        if (max1 < newReserve1) {\n\n            _safeTransfer(pylonToken.anchor, pairAddress, newReserve1.sub(max1));\n            (ptl,,) = IZirconPair(pairAddress).mintOneSide(address(this), !isFloatReserve0);\n            reserve1 = max1;\n        }else{\n            reserve1 = uint112(newReserve1);\n        }\n        emit PylonUpdate(reserve0, reserve1);\n    }\n\n\n\n    // ****** UPDATE ********\n\n    // Update reserves and, on the first call per block, price accumulator\n    // Any excess of balance is going to be donated to the pair\n    // So... here we get the maximum off both tokens and we mint Pool Tokens\n\n    // Sends pylonReserves to pool if there is a match\n    function _update() private {\n        // Let's take the current balances\n        uint balance0 = IERC20Uniswap(pylonToken.float).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(pylonToken.anchor).balanceOf(address(this));\n\n        // Intializing the variables, (Maybe gas consuming let's see how to sort out this\n        // Getting pair reserves and updating variables before minting\n        // Max0 and Max1 are two variables representing the maximum that can be minted on sync\n        // Min0/2 & Min1/2 remain as reserves on the pylon\n        // In the case the pair hasn't been initialized pair reserves will be 0 so we take our current balance as the maximum\n        (uint reservesTranslated0, uint reservesTranslated1) = getPairReservesTranslated(balance0, balance1);\n\n        uint112 max0 = uint112(reservesTranslated0.mul(maximumPercentageSync)/100);\n        uint112 max1 = uint112(reservesTranslated1.mul(maximumPercentageSync)/100);\n        // Pylon Update Minting\n        if (balance0 > max0/2 && balance1 > max1/2) {\n            // Get Maximum simple gets the maximum quantity of token that we can mint\n            (uint px, uint py) = ZirconLibrary._getMaximum(\n                reservesTranslated0,\n                reservesTranslated1,\n                balance0.sub(max0/2), balance1.sub(max1/2));\n            // Transferring tokens to pair and minting\n            if(px != 0) _safeTransfer(pylonToken.float, pairAddress, px);\n            if(py != 0) _safeTransfer(pylonToken.anchor, pairAddress, py);\n            IZirconPair(pairAddress).mint(address(this));\n            balance0 -= px;\n            balance1 -= py;\n\n        }\n        // Let's remove the tokens that are above max0 and max1, and donate them to the pool\n        // This is for cases where somebody just donates tokens to pylon; tx reverts if this done via core functions\n        //Todo: This is likely also invoked if the price dumps and the sync pool is suddenly above max, not ideal behavior...\n\n        updateReservesRemovingExcess(balance0, balance1, max0, max1);\n        _updateVariables();\n\n        // Updating Variables\n    }\n    // @notice This Function is called to update some variables needed for calculation\n    function _updateVariables() private {\n        (uint112 _pairReserve0, uint112 _pairReserve1) = getPairReservesNormalized();\n        lastPoolTokens = IZirconPair(pairAddress).totalSupply();\n        lastK = uint(_pairReserve0).mul(_pairReserve1);\n\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        //uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        blockTimestampLast = blockTimestamp;\n    }\n\n    // ***** MINTING *****\n\n    // @notice Mint Pool Token\n    // @_balance -> Balance OF PT\n    // @_pylonReserve -> Reserves of PT on Pylon\n    function _mintPoolToken(uint amountIn,\n        uint _pylonReserve, uint _pairReserveTranslated,\n        address _poolTokenAddress, address _to,  bool isAnchor) private returns (uint liquidity, uint amountOut) {\n        require(amountIn > 0, \"ZP: Not Enough Liquidity\");\n        // Taking the fee out in tokens\n\n        uint pts = IZirconPoolToken(_poolTokenAddress).totalSupply();\n        {\n            uint _gamma = gammaMulDecimals;\n            uint _vab = virtualAnchorBalance;\n\n            if (pts == 0) {\n                //TODO: Double check if we can start the pool with no fees\n                IZirconPoolToken(_poolTokenAddress).mint(address(0), MINIMUM_LIQUIDITY);\n                if (isAnchor) {\n                    liquidity = amountIn.sub(MINIMUM_LIQUIDITY);\n                }else{\n                    liquidity = (amountIn.mul(1e18)/_gamma.mul(2)).sub(MINIMUM_LIQUIDITY);\n                }\n            } else {\n                // Paying fees only on not init call\n                amountOut = payFees(amountIn, isAnchor);\n                liquidity = ZirconLibrary.calculatePTU(isAnchor, amountOut, pts, _pairReserveTranslated, _pylonReserve, _gamma, _vab);\n\n            }\n        }\n        IZirconPoolToken(_poolTokenAddress).mint(_to, liquidity);\n        emit MintSync(msg.sender, amountOut, isAnchor);\n    }\n\n    // @notice External Function called to mint pool Token\n    // @dev Liquidity have to be sent before\n    // TODO: recheck in dump scenario if sync pool can be blocked\n\n    // aka syncMint\n    function mintPoolTokens(address _to, bool isAnchor) isInitialized nonReentrant external returns (uint liquidity) {\n        sync();\n\n        (uint112 _reserve0, uint112 _reserve1,) = getSyncReserves();\n        (uint _reservePairTranslated0, uint _reservePairTranslated1) = getPairReservesTranslated(0, 0);\n        uint amountIn;\n        uint amountOut;\n        // Minting Pool tokens\n        if (isAnchor) {\n            uint balance1 = IERC20Uniswap(pylonToken.anchor).balanceOf(address(this));\n            amountIn = balance1.sub(_reserve1);\n\n            (liquidity, amountOut ) = _mintPoolToken(amountIn, _reserve1, _reservePairTranslated1, anchorPoolTokenAddress, _to, isAnchor);\n        } else {\n            uint balance0 = IERC20Uniswap(pylonToken.float).balanceOf(address(this));\n            amountIn = balance0.sub(_reserve0);\n            (liquidity, amountOut) = _mintPoolToken(amountIn, _reserve0, _reservePairTranslated0, floatPoolTokenAddress, _to, isAnchor);\n        }\n        // Updating VAB & VFB\n        if(isAnchor) {\n            virtualAnchorBalance += amountOut;\n        }else{\n            virtualFloatBalance += amountOut;\n        }\n        //Sends tokens into pool if there is a match\n        _update();\n    }\n\n\n    /// @notice Private function that calculates anchor fees to send to energy\n    /// @dev in case the user adds liquidity in float token it will swap the amount of tokens with the Pair\n    /// @return amount minus fees payed\n\n    //Swapping every time is not ideal for gas, but it will be changed if we ever deploy to a chain like ETH\n    function payFees(uint amountIn, bool isAnchor) private returns (uint amountOut){\n        uint fee = amountIn.mul(dynamicFeePercentage)/10000; //1basis point resolution\n        if (isAnchor) {\n            _safeTransfer(pylonToken.anchor, energyAddress, fee);\n        } else {\n            _safeTransfer(pylonToken.float, pairAddress, fee);\n            (uint112 _reservePair0, uint112 _reservePair1) = getPairReservesNormalized();\n            uint amountSwapped = ZirconLibrary.getAmountOut(fee, _reservePair0, _reservePair1);\n            IZirconPair(pairAddress).swap(isFloatReserve0 ? 0 : amountSwapped, isFloatReserve0 ? amountSwapped : 0, energyAddress, \"\");\n        }\n        amountOut =  amountIn.sub(fee);\n    }\n\n    /// @notice private function that sends to pair the LP tokens\n    /// Burns them sending it to the energy address\n    function payBurnFees(uint amountIn) private returns (uint amountOut) {\n        uint fee = amountIn.mul(dynamicFeePercentage)/10000;\n        _safeTransfer(pairAddress, pairAddress, fee);\n        IZirconPair(pairAddress).burnOneSide(energyAddress, !isFloatReserve0);\n        amountOut = amountIn.sub(fee);\n    }\n\n    /// @notice private function that calculates fees for Burn Async\n    /// Fees here are increased depending on current Gamma\n    /// on unbalanced Gamma, fees are higher\n    function payBurnAsyncFees(uint amountIn) private returns (uint amountOut) {\n        uint gammaFee = IZirconEnergy(energyAddress).getFeeByGamma(gammaMulDecimals);\n        uint fee = amountIn.mul(dynamicFeePercentage + gammaFee/2)/10000;\n        address revAddress = IZirconPair(pairAddress).energyRevenueAddress();\n        _safeTransfer(pairAddress, revAddress, amountIn.mul(gammaFee/2)/10000);\n        IZirconEnergyRevenue(revAddress).calculate();\n\n        _safeTransfer(pairAddress, pairAddress, fee);\n        IZirconPair(pairAddress).burnOneSide(energyAddress, !isFloatReserve0);\n        amountOut = amountIn.sub(fee);\n    }\n\n\n    // @notice Mint Async 100 lets you invest in one liquidity\n    // The difference with Sync Liquidity is that it goes directly to the Pool\n\n    function mintAsync100(address to, bool isAnchor) nonReentrant isInitialized external returns (uint liquidity) {\n        sync();\n\n        (uint112 _reserve0, uint112 _reserve1,) = getSyncReserves();\n        uint amountIn;\n        if (isAnchor) {\n            uint balance = IERC20Uniswap(pylonToken.anchor).balanceOf(address(this));\n            amountIn = balance.sub(_reserve1);\n        }else{\n            uint balance = IERC20Uniswap(pylonToken.float).balanceOf(address(this));\n            amountIn = balance.sub(_reserve0);\n        }\n\n        amountIn = payFees(amountIn, isAnchor);\n        require(amountIn > 0, \"ZP: INSUFFICIENT_AMOUNT\");\n        _safeTransfer(isAnchor ? pylonToken.anchor : pylonToken.float, pairAddress, amountIn);\n        {\n            (uint a0, uint a1) = _disincorporateAmount(amountIn, isAnchor);\n\n            (uint _liquidity, uint amount) = getLiquidityFromPoolTokens(\n                a0, a1,\n                isAnchor,\n                IZirconPoolToken(isAnchor ? anchorPoolTokenAddress : floatPoolTokenAddress));\n\n            liquidity = _liquidity;\n            if (isAnchor) {\n                virtualAnchorBalance += amount;\n            }else{\n                virtualFloatBalance += amount;\n            }\n\n            IZirconPair(pairAddress).mintOneSide(address(this), isFloatReserve0 ? !isAnchor : isAnchor);\n            IZirconPoolToken(isAnchor ? anchorPoolTokenAddress : floatPoolTokenAddress).mint(to, liquidity);\n        }\n\n        _updateVariables();\n        emit MintAsync100(msg.sender, amountIn, isAnchor);\n    }\n\n\n    // @notice Mint Async lets you invest in both liquidity like you normally do on your DEX\n    // The difference is that gives you directly with mint one side\n    // TODO: Transfer first then calculate on basis of pool token share how many share we should give to the user\n    function mintAsync(address to, bool shouldMintAnchor) external nonReentrant isInitialized returns (uint liquidity){\n        sync();\n        address _poolTokenAddress = shouldMintAnchor ? anchorPoolTokenAddress : floatPoolTokenAddress;\n\n        (uint112 _reserve0, uint112 _reserve1,) = getSyncReserves(); // gas savings\n        uint amountIn0;\n        uint amountIn1;\n        {\n            uint balance0 = IERC20Uniswap(pylonToken.float).balanceOf(address(this));\n            uint balance1 = IERC20Uniswap(pylonToken.anchor).balanceOf(address(this));\n\n            amountIn0 = balance0.sub(_reserve0);\n            amountIn1 = balance1.sub(_reserve1);\n\n            amountIn0 = payFees(amountIn0, false);\n            amountIn1 = payFees(amountIn1, true);\n\n            (uint _liquidity, uint amount) = getLiquidityFromPoolTokens(amountIn0, amountIn1, shouldMintAnchor, IZirconPoolToken(_poolTokenAddress));\n            liquidity = _liquidity;\n            if (shouldMintAnchor) {\n                virtualAnchorBalance += amount;\n            } else {\n                virtualFloatBalance += amount;\n            }\n\n        }\n\n        require(amountIn1 > 0 && amountIn0 > 0, \"ZirconPylon: Not Enough Liquidity\");\n        _safeTransfer(pylonToken.float, pairAddress, amountIn0);\n        _safeTransfer(pylonToken.anchor, pairAddress, amountIn1);\n        IZirconPair(pairAddress).mint(address(this));\n        // uint deltaSupply = pair.totalSupply().sub(_totalSupply);\n        //TODO: Change fee\n        IZirconPoolToken(_poolTokenAddress).mint(to, liquidity);\n\n\n        emit MintAsync(msg.sender, amountIn0, amountIn1);\n        //console.log(\"<<<Pylon:mintAsync::::::::\", liquidity);\n        _updateVariables();\n    }\n\n\n    /// @notice sync lets you enter with one liquidity getting or anchor or float shares\n    function sync() private {\n        // Prevents this from being called while the underlying pool is getting flash loaned\n        if(msg.sender != pairAddress) { IZirconPair(pairAddress).tryLock(); }\n\n        // So this thing needs to get pool reserves, get the price of the float asset in anchor terms\n        // Then it applies the base formula:\n        // Adds fees to virtualFloat and virtualAnchor\n        // And then calculates Gamma so that the proportions are correct according to the formula\n        (uint112 pairReserve0, uint112 pairReserve1) = getPairReservesNormalized();\n        (uint112 pylonReserve0, uint112 pylonReserve1,) = getSyncReserves();\n\n        // If the current K is equal to the last K, means that we haven't had any updates on the pair level\n        // So is useless to update any variable because fees on pair haven't changed\n        uint currentK = uint(pairReserve0).mul(pairReserve1);\n        if (lastPoolTokens != 0 && pairReserve0 != 0 && pairReserve1 != 0) {\n\n            uint poolTokensPrime = IZirconPair(pairAddress).totalSupply();\n            // Here it is going to be useful to have a Minimum Liquidity\n            // If not we can have some problems\n            // uint poolTokenBalance = IZirconPair(pairAddress).balanceOf(address(this));\n            // Let's get the amount of total pool value own by pylon\n\n            // TODO: Add system that accumulates fees to cover insolvent withdrawals (and thus changes ptb)\n            // TODO: Add impact of Anchor/Float pts\n\n            uint totalPoolValueAnchorPrime = translateToPylon(pairReserve1.mul(2), 0);\n            uint totalPoolValueFloatPrime = translateToPylon(pairReserve0.mul(2), 0);\n\n            uint one = 1e18;\n            uint d = (one).sub((Math.sqrt(lastK)*poolTokensPrime*1e18)/(Math.sqrt(currentK)*lastPoolTokens));\n\n            // Getting how much fee value has been created for pylon\n            uint feeValueAnchor = totalPoolValueAnchorPrime.mul(d)/1e18;\n            uint feeValueFloat = totalPoolValueFloatPrime.mul(d)/1e18;\n//            console.log(\"sync::anchor::fee\", feeValueAnchor);\n//            console.log(\"sync::float::fee\", feeValueFloat);\n\n            // Calculating gamma, variable used to calculate tokens to mint and withdrawals\n\n            // gamma is supposed to always be an accurate reflection of the float share as a percentage of the totalPoolValue\n            // however vfb also includes the syncPool reserve portion, which is completely outside of the pools.\n            // Nonetheless, the syncPool is still considered part of the user base/float share.\n            // This is relevant primarily for fee calculations, but that's already a given: you just use the same proportions.\n            // In all other places we (should) already account for the sync pool separately.\n\n            // When operating on fractional, gamma is higher than it should be compared to ftv + atv.\n            // This means that anchors get more fees than they \"should\", which kinda works out because they're at high risk.\n            // It works as an additional incentive to not withdraw.\n\n            virtualAnchorBalance += ((feeValueAnchor.mul(1e18-gammaMulDecimals))/1e18);\n            virtualFloatBalance += ((gammaMulDecimals).mul(feeValueFloat)/1e18);\n\n            if ((virtualAnchorBalance.sub(pylonReserve1)) < totalPoolValueAnchorPrime/2) {\n                gammaMulDecimals = 1e18 - ((virtualAnchorBalance.sub(pylonReserve1))*1e18 /  totalPoolValueAnchorPrime);\n            } else {\n                //TODO: Check that this works and there are no gamma that assume gamma is ftv/atv+ftv\n                gammaMulDecimals = ((virtualFloatBalance.sub(pylonReserve0)) *1e18) /  totalPoolValueFloatPrime;\n            }\n\n            // TODO: (see if make sense to insert a floor to for example 25/75)\n            // Sync pool also gets a claim to these\n            emit PylonSync(virtualAnchorBalance, virtualFloatBalance, gammaMulDecimals);\n        }\n    }\n\n\n    /// @notice TODO\n    function calculateLPTU(bool _isAnchor, uint _liquidity, uint _ptTotalSupply) view private returns (uint claim){\n        (uint _reserve0, uint _reserve1) = getPairReservesTranslated(1, 1); // gas savings\n        (uint112 _pylonReserve0, uint112 _pylonReserve1,) = getSyncReserves(); // gas savings\n        uint pylonShare;\n        if (_isAnchor) {\n            pylonShare = (IZirconPair(pairAddress).balanceOf(address(this)).mul(virtualAnchorBalance.sub(_pylonReserve1)))/_reserve1.mul(2);\n            // Adjustment factor to extract correct amount of liquidity\n            pylonShare = pylonShare.add(pylonShare.mul(_pylonReserve1)/_reserve1.mul(2));\n        }else{\n            pylonShare = ((gammaMulDecimals).mul(IZirconPair(pairAddress).balanceOf(address(this))))/1e18;\n            pylonShare = pylonShare.add(pylonShare.mul(_pylonReserve0)/_reserve0.mul(2));\n        }\n\n\n        // Liquidity/pt applies share over pool + reserves to something that is just pool.\n        // So it gives less liquidity than it should\n\n        claim = (_liquidity.mul(pylonShare))/_ptTotalSupply;\n        require(claim > 0, 'ZP: INSUFFICIENT_LIQUIDITY_BURNED');\n    }\n\n    /// @notice TODO\n    // Burn Async send both tokens 50-50\n    // Liquidity has to be sent before\n    function sendSlashing(uint omegaMulDecimals, uint liquidity) private returns(uint remainingPercentage){\n        if (omegaMulDecimals < 1e18) {\n            uint amountToAdd = liquidity.mul(1e18-omegaMulDecimals)/1e18;\n            // uint energyAnchorBalance = IERC20Uniswap(pylonToken.anchor).balanceOf(energyAddress);\n            uint energyPTBalance = IERC20Uniswap(pairAddress).balanceOf(energyAddress);\n            if (amountToAdd < energyPTBalance) {\n                // Sending PT tokens to Pair because burn one side is going to be called after\n                _safeTransferFrom(pairAddress, energyAddress, pairAddress, amountToAdd);\n                remainingPercentage = 0;\n            } else {\n                // Sending PT tokens to Pair because burn one side is going to be called after\n                // @dev if amountToAdd is too small the remainingPercentage will be 0 so that is ok\n                _safeTransferFrom(pairAddress, energyAddress, pairAddress, energyPTBalance);\n                remainingPercentage = (amountToAdd.sub(energyPTBalance))/(liquidity);\n            }\n        }else{\n            remainingPercentage = 0;\n        }\n    }\n\n    /// @notice function that sends tokens to Pair to be burn after\n    /// this function must be called only before a burn takes place, if not it'll give away tokens\n    function sendSlashedTokensToUser(uint anchorAmount, uint floatAmount, uint percentage, address _to) private {\n        if(percentage != 0) {\n            uint totalAmount = anchorAmount;\n            if ( floatAmount > 0 ) {\n                (uint res0, uint res1) = getPairReservesNormalized();\n                totalAmount += ZirconLibrary.getAmountOut(floatAmount, res0, res1);\n            }\n            uint energyAnchorBalance = IERC20Uniswap(pylonToken.anchor).balanceOf(energyAddress);\n            uint amountToTransfer = totalAmount.mul(percentage);\n            if(energyAnchorBalance > amountToTransfer ){\n                _safeTransferFrom(pylonToken.anchor, energyAddress, _to, amountToTransfer);\n            }\n            console.log(\"Sending slashed Tokens\", amountToTransfer);\n        }\n    }\n\n\n    /// @notice Burn Async let's you burn your anchor|float shares giving you back both tokens\n    /// @dev sends to the Pair Contract the PTU equivalent to the Anchor|Float Shares\n    /// and calls Classic burn\n    function burnAsync(address _to, bool _isAnchor) external nonReentrant isInitialized returns (uint amount0, uint amount1) {\n        sync();\n\n        IZirconPoolToken pt = IZirconPoolToken(_isAnchor ? anchorPoolTokenAddress : floatPoolTokenAddress);\n        uint liquidity = pt.balanceOf(address(this));\n        require(liquidity > 0, \"ZP: Not enough liquidity inserted\");\n        uint ptTotalSupply = pt.totalSupply();\n        uint extraPercentage = 0;\n\n        {\n            (uint reserveFloat, uint reserveAnchor,) = getSyncReserves();\n            (uint pairReserves0,) = getPairReservesTranslated(0, 0);\n            {\n                //Calculates max liquidity to avoid withdrawing portion in sync pools\n                uint maxPoolTokens = _isAnchor ?\n                ptTotalSupply - ptTotalSupply.mul(reserveAnchor) / virtualAnchorBalance :\n                ptTotalSupply - ptTotalSupply.mul(reserveFloat) / (pairReserves0.mul(2).mul(gammaMulDecimals) / 1e18).add(reserveFloat);\n                require(liquidity < maxPoolTokens, \"ZP: Exceeded Burn Async limit\");\n            }\n            uint ptu = calculateLPTU(_isAnchor, liquidity, ptTotalSupply);\n            ptu = payBurnFees(ptu);\n            // Anchor slashing logic\n            if (_isAnchor) {\n                (ptu, extraPercentage) = handleOmegaSlashing(ptu);\n            }\n            _safeTransfer(pairAddress, pairAddress, ptu);\n        }\n        // Burning liquidity and sending to user\n        // The pool tokens sent to the Pair are slashed by omega\n        (uint amountA, uint amountB) = IZirconPair(pairAddress).burn(_to);\n        amount0 = isFloatReserve0 ? amountA : amountB;\n        amount1 = isFloatReserve0 ? amountB : amountA;\n        sendSlashedTokensToUser(amount0, amount1, extraPercentage, _to);\n\n        //Burns the Zircon pool tokens\n        pt.burn(address(this), liquidity);\n\n        // Updating\n        updateVirtualBalancesBurn(liquidity, ptTotalSupply, _isAnchor);\n        _update();\n\n        // Emiting event on burned async\n        emit BurnAsync(msg.sender, amount0, amount1);\n    }\n\n    /// @notice function that simples updates both VAB and VFB\n    function updateVirtualBalancesBurn(uint _liquidity, uint _totalSupply, bool _isAnchor) private {\n        if(_isAnchor) {\n            virtualAnchorBalance -= virtualAnchorBalance.mul(_liquidity)/_totalSupply;\n        }else{\n            virtualFloatBalance -= virtualFloatBalance.mul(_liquidity)/_totalSupply;\n        }\n    }\n\n    /// @notice Function That handles the amount of reserves in Float Anchor Shares\n    /// and the amount of the minimum from liquidity and reserves\n    /// @dev Helper function for burn\n    function burnPylonReserves(bool isAnchor, uint _totalSupply, uint _liquidity) view private returns (uint reservePT, uint amount) {\n        // variables declaration\n        uint _gamma = gammaMulDecimals;\n        uint _vab = virtualAnchorBalance;\n        (uint _reserve0,) = getPairReservesTranslated(0,0); // gas savings\n        (uint112 _pylonReserve0, uint112 _pylonReserve1,) = getSyncReserves();\n\n        //Calculates maxPTs that can be serviced through Pylon Reserves\n        uint pylonReserve = isAnchor ? _pylonReserve1 : _pylonReserve0;\n        uint reserve = isAnchor ? reserve1 : _reserve0;\n        reservePT = ZirconLibrary.calculatePTU(isAnchor, pylonReserve, _totalSupply, reserve, pylonReserve, _gamma, _vab);\n        amount = ZirconLibrary.calculatePTUToAmount(isAnchor, Math.min(reservePT, _liquidity), _totalSupply,reserve, pylonReserve, _gamma, _vab);\n    }\n\n\n    /// @notice Omega is the slashing factor. It's always equal to 1 if pool has gamma above 50%\n    /// If it's below 50%, it begins to go below 1 and thus slash any withdrawal.\n    /// @dev Note that in practice this system doesn't activate unless the syncReserves are empty.\n    /// Also note that a dump of 60% only generates about 10% of slashing.\n    function handleOmegaSlashing(uint ptu) private returns (uint retPtu, uint extraPercentage){\n        (, uint reserveAnchor,) = getSyncReserves();\n        (, uint pairReserves1)  = getPairReservesTranslated(0,0);\n        uint omegaMulDecimals = ZirconLibrary.slashLiabilityOmega(\n            pairReserves1.mul(2),\n            reserveAnchor,\n            gammaMulDecimals,\n            virtualAnchorBalance);\n        console.log(\"omega slash\", omegaMulDecimals);\n        (extraPercentage) = sendSlashing(omegaMulDecimals, ptu);\n        retPtu = omegaMulDecimals.mul(ptu)/1e18;\n    }\n\n    // @notice Burn send liquidity back to user burning Pool tokens\n    // The function first uses the reserves of the Pylon\n    // If not enough reserves it burns The Pool Tokens of the pylon\n    // Fees here are\n    function burn(address _to, bool _isAnchor) external nonReentrant isInitialized returns (uint amount){\n        sync();\n        // Selecting the Pool Token class on basis of the requested tranch to burn\n        IZirconPoolToken pt = IZirconPoolToken(_isAnchor ? anchorPoolTokenAddress : floatPoolTokenAddress);\n        // Let's get how much liquidity was sent to burn\n        // Outside of scope to be used for vab/vfb adjustment later\n        uint liquidity = pt.balanceOf(address(this));\n        require(liquidity > 0, \"INSUFFICIENT_LIQUIDITY\");\n        uint _totalSupply = pt.totalSupply();\n        {\n            address to = _to;\n            bool isAnchor = _isAnchor;\n            address _pairAddress = pairAddress;\n            // Here we calculate max PTU to extract from sync reserve + amount in reserves\n            (uint reservePT, uint _amount) = burnPylonReserves(isAnchor, _totalSupply, liquidity);\n            amount = payFees(_amount, isAnchor);\n            _safeTransfer(isAnchor ? pylonToken.anchor : pylonToken.float, to, amount);\n\n            //In case the reserves weren't able to pay for everything\n            if (reservePT < liquidity) {\n                uint adjustedLiquidity = liquidity.sub(reservePT);\n                uint ptu = calculateLPTU(isAnchor, adjustedLiquidity, _totalSupply);\n                ptu = payBurnFees(ptu);\n                uint extraPercentage = 0;\n                if (isAnchor) { (ptu, extraPercentage) = handleOmegaSlashing(ptu); }\n                _safeTransfer(_pairAddress, _pairAddress, ptu);\n                bool isReserve0 = isFloatReserve0 ? !isAnchor : isAnchor;\n                uint sentAmount = IZirconPair(_pairAddress).burnOneSide(to, isReserve0);  // XOR\n                amount += sentAmount;\n                sendSlashedTokensToUser(isReserve0 ? sentAmount : 0, isReserve0 ? 0 : sentAmount, extraPercentage, to);\n                //Bool combines choice of anchor or float with which token is which in the pool\n            }\n            pt.burn(address(this), liquidity); //Should burn unadjusted amount ofc\n        }\n\n        updateVirtualBalancesBurn(liquidity, _totalSupply, _isAnchor);\n        _update();\n        emit Burn(msg.sender, amount, _isAnchor);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.5.16;\n// a library for performing various math operations\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        z = x > y ? x : y;\n    }\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IZirconPoolToken.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IZirconPoolToken {\n    function factory() external view returns (address);\n    function isAnchor() external view returns (bool);\n    function token() external view returns (address);\n    function pair() external view returns (address);\n    function pylon() external view returns (address);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n\n    function mint(address account, uint256 amount) external;\n    function burn(address account, uint256 amount) external;\n    function initialize(address _token0, address _pair, address _pylon, bool _isAnchor) external;\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.5.16;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.5.16;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/libraries/ZirconLibrary.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary ZirconLibrary {\n    using SafeMath for uint256;\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n\n    // Same Function as Uniswap Library, used here for incompatible solidity versions\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // TODO: check getAmountsOut function of v2 library, they use a slightly different formula\n    // This function takes two variables and look at the maximum possible with the ration given by the reserves\n    // @pR0, @pR1 the pair reserves\n    // @b0, @b1 the balances to calculate\n    function _getMaximum(uint _reserve0, uint _reserve1, uint _b0, uint _b1) pure internal returns (uint maxX, uint maxY)  {\n\n        //Expresses b1 in units of reserve0\n        uint px = _reserve0.mul(_b1)/_reserve1;\n\n        if (px > _b0) {\n            maxX = _b0;\n            maxY = _b0.mul(_reserve1)/_reserve0; //b0 in units of reserve1\n        } else {\n            maxX = px; //max is b1 but in reserve0 units\n            maxY = _b1;\n        }\n    }\n\n\n    // @notice This function converts amount, specifying which tranch uses with @isAnchor, to pool token share\n    // @_amount is the quantity to convert\n    // @_totalSupply is the supply of the pt's tranch\n    // @reserve0, @_gamma, @vab are the variables needed to the calculation of the amount\n    function calculatePTU(bool _isAnchor, uint _amount, uint _totalSupply, uint _reserve, uint _reservePylon, uint _gamma, uint _vab) pure internal returns (uint liquidity){\n        if (_isAnchor) {\n            liquidity = _amount.mul(_totalSupply)/_vab;\n        }else {\n            uint numerator = _amount.mul(_totalSupply);\n            uint resTranslated = _reserve.mul(_gamma).mul(2)/1e18;\n            uint denominator = (_reservePylon.add(resTranslated));\n\n            liquidity = (numerator/denominator);\n        }\n    }\n\n    // @notice This function converts pool token share, specifying which tranches with @isAnchor, to token amount\n    // @_ptuAmount is the quantity to convert\n    // @_totalSupply is the supply of the pt of the tranches\n    // @reserve0, @_gamma, @vab are the variables needed to the calculation of the amount\n    function calculatePTUToAmount(bool _isAnchor, uint _ptuAmount, uint _totalSupply, uint _reserve0, uint _reservePylon0, uint _gamma, uint _vab) pure internal returns (uint amount) {\n        if (_isAnchor) {\n            amount = _vab.mul(_ptuAmount)/_totalSupply;\n        } else {\n            amount = (((_reserve0.mul(_gamma).mul(2)/1e18).add(_reservePylon0)).mul(_ptuAmount))/_totalSupply;\n        }\n    }\n\n    function slashLiabilityOmega(uint tpvAnchorTranslated, uint anchorReserve, uint gammaMulDecimals, uint virtualAnchorBalance) view internal returns (uint omegaMulDecimals) {\n        //Omega is the \"survival factor\" i.e how much of the anchor balance survives slashing and can be withdrawn.\n        //It's applied to the user's liquidity tokens to avoid changing other core functions.\n        //This adjustment is only used for share calculations, the full amount of tokens is removed.\n        omegaMulDecimals = ((1e18 - gammaMulDecimals).mul(tpvAnchorTranslated))/(virtualAnchorBalance.sub(anchorReserve));\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Uniswap {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IZirconPylonFactory.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IZirconPylonFactory {\n    function maximumPercentageSync() external view returns (uint);\n    function dynamicFeePercentage() external view returns (uint);\n\n    function allPylons(uint p) external view returns (address);\n    function getPylon(address tokenA, address tokenB) external view returns (address pair);\n    function factory() external view returns (address);\n    function energyFactory() external view returns (address);\n    event PylonCreated(address indexed token0, address indexed token1, address poolToken0, address poolToken1, address pylon, address pair);\n    function allPylonsLength() external view returns (uint);\n    function pylonCodeHash() external pure returns (bytes32);\n    // Adding Pylon\n    // First Token is always the Float and the second one is the Anchor\n    function addPylon(address _pairAddress, address _tokenA, address _tokenB) external returns (address pylonAddress);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IZirconPylon.sol": {
      "content": "pragma solidity >=0.5.16;\ninterface IZirconPylon {\n\n    function initialized() external view returns (uint);\n    function anchorPoolTokenAddress() external view returns (address);\n    function floatPoolTokenAddress() external view returns (address);\n    function getSyncReserves() external view returns  (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    // Called once by the factory at time of deployment\n    // @_floatPoolToken -> Contains Address Of Float PT\n    // @_anchorPoolToken -> Contains Address Of Anchor PT\n    // @token0 -> Float token\n    // @token1 -> Anchor token\n    function initialize(address, address, address, address, address, address, address) external;\n    // On init pylon we have to handle two cases\n    // The first case is when we initialize the pair through the pylon\n    // And the second one is when initialize the pylon with a pair al ready existing\n    function initPylon(address _to) external returns (uint floatLiquidity, uint anchorLiquidity);\n    // External Function called to mint pool Token\n    // Liquidity have to be sent before\n    function mintPoolTokens(address to, bool isAnchor) external returns (uint liquidity);\n    function mintAsync100(address to, bool isAnchor) external returns (uint liquidity);\n    function mintAsync(address to, bool shouldMintAnchor) external returns (uint liquidity);\n    // Burn Async send both tokens 50-50\n    // Liquidity has to be sent before\n    function burnAsync(address _to, bool _isAnchor) external returns (uint amount0, uint amount1);\n    // Burn send liquidity back to user burning Pool tokens\n    // The function first uses the reserves of the Pylon\n    // If not enough reserves it burns The Pool Tokens of the pylon\n    function burn(address _to, bool _isAnchor) external returns (uint amount);\n}\n"
    },
    "contracts/energy/interfaces/IZirconEnergy.sol": {
      "content": "pragma solidity ^0.5.16;\n\ninterface IZirconEnergy {\n    function initialize(address _pylon, address _pair, address _token0, address _token1, uint _insurancePerMille, uint _minFee, uint _maxFee) external;\n    function breakPiggybank(uint _requestedLiquidity) external returns (uint returnedLiquidity);\n    function syncPylonFee() external;\n    function syncPairFee() external;\n    function getFeeByGamma(uint gammaMulDecimals) external view returns (uint amount);\n}\n"
    },
    "contracts/energy/interfaces/IZirconEnergyRevenue.sol": {
      "content": "pragma solidity ^0.5.16;\n\ninterface IZirconEnergyRevenue {\n    function initialize(address _pair, address _tokenA, address _tokenB, address energy0, address energy1, address pylon0, address pylon1) external;\n    function calculate() external;\n}\n"
    },
    "contracts/ZirconPylonFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.5.16;\n//import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport './ZirconPoolToken.sol';\nimport './ZirconPylon.sol';\nimport \"./energy/interfaces/IZirconEnergyRevenue.sol\";\nimport './energy/interfaces/IZirconEnergyFactory.sol';\n\ncontract ZirconPylonFactory is IZirconPylonFactory {\n    mapping(address => mapping(address => address)) public getPylon;\n    address[] public allPylons;\n    address public factory;\n    address public energyFactory;\n\n    uint public maximumPercentageSync;\n    uint public dynamicFeePercentage;\n    bytes4 private constant CREATE = bytes4(keccak256(bytes('createEnergy(address,address,address,address)')));\n\n    event PylonCreated(address indexed token0, address indexed token1, address poolToken0, address poolToken1, address pylon, address pair);\n\n    constructor(address _factory, address _energyFactory) public {\n        factory = _factory;\n        energyFactory = _energyFactory;\n        maximumPercentageSync = 10;\n        dynamicFeePercentage = 5;\n    }\n\n    function allPylonsLength() external view returns (uint) {\n        return allPylons.length;\n    }\n\n    function pylonCodeHash() external pure returns (bytes32) {\n        return keccak256(type(ZirconPylon).creationCode);\n    }\n\n    function createTokenAddress(address _token, address pylonAddress) private returns (address poolToken) {\n        // Creating Token\n        bytes memory bytecode = type(ZirconPoolToken).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_token, pylonAddress));\n        assembly {\n            poolToken := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n    }\n\n    function createPylon( address _tokenA, address _tokenB, address _pair) private returns (address pylon) {\n        // Creating Token\n        bytes memory bytecode = type(ZirconPylon).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_tokenA, _tokenB, _pair));\n        assembly {\n            pylon := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n    }\n    function createEnergy(address _pylonAddress, address _pairAddress, address _tokenA, address _tokenB) private returns (address energy){\n        energy = IZirconEnergyFactory(energyFactory).createEnergy( _pylonAddress, _pairAddress, _tokenA, _tokenB);\n        //energyRev = IZirconEnergyFactory(energyFactory).createEnergyRev(_pairAddress, _tokenA, _tokenB, address(this));\n\n        //        (bool success, bytes memory data) = energyFactory.call(abi.encodeWithSelector(CREATE, _pylonAddress, _pairAddress, _tokenA, _tokenB));\n//        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ZP: ENERGY_FAILED_CREATION');\n    }\n\n    // Adding Pylon\n    // First Token is always the Float and the second one is the Anchor\n    function addPylon(address _pairAddress, address _tokenA, address _tokenB) external returns (address pylonAddress) {\n        require(_tokenA != _tokenB, 'ZF: IDENTICAL_ADDRESSES');\n        require(getPylon[_tokenA][_tokenB] == address(0), 'ZF: PYLON_EXISTS');\n\n        pylonAddress = createPylon(_tokenA, _tokenB, _pairAddress);\n        address poolTokenA = createTokenAddress(_tokenA, pylonAddress); // Float\n        address poolTokenB = createTokenAddress(_tokenB, pylonAddress); // Anchor\n\n        address energy = createEnergy(pylonAddress, _pairAddress, _tokenA, _tokenB);\n\n        IZirconPylon(pylonAddress).initialize(poolTokenA, poolTokenB, _tokenA, _tokenB, _pairAddress, factory, energy);\n\n        ZirconPoolToken(poolTokenA).initialize(_tokenA, _pairAddress, pylonAddress, false);\n        ZirconPoolToken(poolTokenB).initialize(_tokenB, _pairAddress, pylonAddress, true);\n\n        emit PylonCreated(_tokenA, _tokenB, poolTokenA, poolTokenB, pylonAddress, _pairAddress);\n\n\n        getPylon[_tokenA][_tokenB] = pylonAddress;\n        allPylons.push(pylonAddress);\n    }\n}\n"
    },
    "contracts/ZirconPoolToken.sol": {
      "content": "pragma solidity ^0.5.16;\nimport \"./ZirconERC20.sol\";\nimport \"./interfaces/IZirconPoolToken.sol\";\n\ncontract ZirconPoolToken is ZirconERC20 {\n    address public token;\n    address public pair;\n    bool public isAnchor;\n    address public factory;\n    address public pylon;\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function mint(address account, uint256 amount) lock external {\n        require(msg.sender == pylon, 'ZirconPoolToken: FORBIDDEN');\n        // sufficient check\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) lock external {\n        require(msg.sender == pylon, 'ZirconPoolToken: FORBIDDEN');\n        // sufficient check\n        _burn(account, amount);\n    }\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _pair, address _pylon, bool _isAnchor) external {\n        require(msg.sender == factory, 'ZirconPoolToken: FORBIDDEN');\n        // sufficient check\n        token = _token0;\n        pair = _pair;\n        isAnchor = _isAnchor;\n        pylon = _pylon;\n    }\n}\n"
    },
    "contracts/energy/interfaces/IZirconEnergyFactory.sol": {
      "content": "pragma solidity =0.5.16;\n\ninterface IZirconEnergyFactory {\n\n    // Variables\n    function allEnergies(uint p) external view returns (address);\n    function getEnergy(address _tokenA, address _tokenB) external view returns (address pair);\n    function allEnergiesLength() external view returns (uint);\n    function energyCodeHash() external pure returns (bytes32);\n\n    // Functions\n    function createEnergy(address, address, address, address) external returns (address energy);\n    function createEnergyRev(address, address, address, address) external returns (address energy);\n\n}\n"
    },
    "contracts/ZirconERC20.sol": {
      "content": "pragma solidity =0.5.16;\nimport './interfaces/IUniswapV2ERC20.sol';\nimport './libraries/SafeMath.sol';\n\ncontract ZirconERC20 is IUniswapV2ERC20 {\n    using SafeMath for uint;\n    // TODO: change name of token\n    string public constant name = 'Zircon';\n    string public constant symbol = 'ZPT';\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint)  public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n    bytes32 public DOMAIN_SEPARATOR;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/ZirconFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.5.16;\nimport './ZirconPair.sol';\nimport './energy/interfaces/IZirconEnergyFactory.sol';\nimport \"./energy/interfaces/IZirconEnergyRevenue.sol\";\n\ncontract ZirconFactory is IZirconFactory {\n//    address public feeTo;\n//    address public feeToSetter;\n    address public migrator;\n    address public energyFactory;\n    bytes4 private constant CREATE = bytes4(keccak256(bytes('createEnergyRev(address,address,address,address)')));\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _energyFactory) public {\n        energyFactory = _energyFactory;\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(ZirconPair).creationCode);\n    }\n\n    function createEnergy( address _pairAddress, address _tokenA, address _tokenB, address _pylonFactory) private returns (address energy){\n        energy = IZirconEnergyFactory(energyFactory).createEnergyRev(_pairAddress, _tokenA, _tokenB, _pylonFactory);\n//        (bool success, bytes memory data) = energyFactory.call(abi.encodeWithSelector(CREATE, _pairAddress, _tokenA, _tokenB, _pylonFactory));\n//        require(success, 'ZP: ENERGYREV_FAILED_CREATION');\n//        energy = abi.decode(data, (address));\n    }\n\n    function createPair(address tokenA, address tokenB, address _pylonFactory) external returns (address pair) {\n        require(tokenA != tokenB, 'ZF: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZF: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'ZF: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(ZirconPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        address energyRev = createEnergy(pair, token0, token1, _pylonFactory);\n        IZirconPair(pair).initialize(token0, token1, energyRev);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n//    function setFeeTo(address _feeTo) external  {\n//        require(msg.sender == feeToSetter, 'ZF: FORBIDDEN');\n//        feeTo = _feeTo;\n//    }\n//    function setMigrator(address _migrator) external {\n//        require(msg.sender == feeToSetter, 'ZF: FORBIDDEN');\n//        migrator = _migrator;\n//    }\n//    function setFeeToSetter(address _feeToSetter) external  {\n//        require(msg.sender == feeToSetter, 'ZF: FORBIDDEN');\n//        feeToSetter = _feeToSetter;\n//    }\n\n}\n"
    },
    "contracts/ZirconPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.5.16;\n\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IZirconPair.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol';\nimport './libraries/SafeMath.sol';\nimport \"./ZirconERC20.sol\";\nimport \"./interfaces/IZirconFactory.sol\";\n//import \"./libraries/////console.sol\";\nimport \"./libraries/ZirconLibrary.sol\";\nimport \"./energy/interfaces/IZirconEnergyRevenue.sol\";\n\ninterface IMigrator {\n    // Return the desired amount of liquidity token that the migrator wants.\n    function desiredLiquidity() external view returns (uint256);\n}\n\ncontract ZirconPair is IZirconPair, ZirconERC20 { //Name change does not affect ABI\n    using SafeMath for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    address public energyRevenueAddress;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // us es single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()  public view returns  (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    function tryLock() external lock {}\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1, address _energy) external {\n        require(msg.sender == factory, 'ZirconPair: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        energyRevenueAddress = _energy;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1,\n        uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private {\n        uint _kLast = kLast; // gas savings\n        if (_kLast != 0) {\n            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n            uint rootKLast = Math.sqrt(_kLast);\n            if (rootK > rootKLast) {\n\n                //TODO: Add dynamic percentage here\n\n                uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                uint denominator = rootK.mul(5).add(rootKLast);\n                uint liquidity = numerator / denominator;\n                if (liquidity > 0) {\n                    _mint(energyRevenueAddress, liquidity);\n                    IZirconEnergyRevenue(energyRevenueAddress).calculate();\n                }\n            }\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            address migrator = IZirconFactory(factory).migrator();\n            if (msg.sender == migrator) {\n                liquidity = IMigrator(migrator).desiredLiquidity();\n                require(liquidity > 0 && liquidity != uint256(-1), \"ZirconPair: Bad desired liquidity\");\n            } else {\n                require(migrator == address(0), \"ZirconPair: Must not have migrator\");\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            }\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // TODO: will be better if we pass the output amount\n    function mintOneSide(address to, bool isReserve0) external lock returns (uint liquidity, uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\n        amount0 = balance0.sub(_reserve0);\n        amount1 = balance1.sub(_reserve1);\n        require(amount0 > 1 || amount1 > 1, \"ZP: Insufficient Amount\");\n        if (isReserve0) {\n            amount1 = ZirconLibrary.getAmountOut(amount0/2,reserve0,reserve1);\n            amount0 = amount0/2;\n        }else {\n            amount0 = ZirconLibrary.getAmountOut(amount1/2, reserve1, reserve0);\n            amount1 = amount1/2;\n        }\n\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            address migrator = IZirconFactory(factory).migrator();\n            if (msg.sender == migrator) {\n                liquidity = IMigrator(migrator).desiredLiquidity();\n                require(liquidity > 0 && liquidity != uint256(-1), \"ZirconPair: Bad desired liquidity\");\n            } else {\n                require(migrator == address(0), \"ZirconPair: Must not have migrator\");\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            }\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    //TODO: Test this function\n    //TODO: maybe allow burning both sides to one\n    function burnOneSide(address to, bool isReserve0) external lock returns (uint amount) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint amount0;\n        uint amount1;\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n        //console.log(\"liquidity\", liquidity);\n\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        if (isReserve0) {\n            //console.log(\"amount0\", amount0);\n            amount0 += ZirconLibrary.getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n            //console.log(\"amount0\", amount0);\n            amount = amount0;\n            require(amount < balance0, \"UniswapV2: EXTENSION_NOT_ENOUGH_LIQUIDITY\");\n        }else{\n            //console.log(\"amount1\", amount1);\n            amount1 += ZirconLibrary.getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n            //console.log(\"amount1\", amount1);\n            amount = amount1;\n            require(amount < balance1, \"UniswapV2: EXTENSION_NOT_ENOUGH_LIQUIDITY\");\n        }\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        if (isReserve0) {\n            _safeTransfer(_token0, to, amount);\n        }else{\n            _safeTransfer(_token1, to, amount);\n        }\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n        _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data)  external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\n            // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\n            // optimistically transfer tokens\n            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n            balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to)  external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/IZirconFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IZirconFactory {\n//    function feeTo() external view returns (address);\n//    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n    function energyFactory() external view returns (address);\n\n    function getPair(address, address) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function pairCodeHash() external pure returns (bytes32);\n    function createPair(address tokenA, address tokenB, address _pylonFactory) external returns (address pair);\n//    function setFeeTo(address _feeTo) external;\n//    function setMigrator(address _migrator) external;\n//    function setFeeToSetter(address _feeToSetter) external;\n}\n"
    },
    "contracts/energy/ZirconEnergy.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.5.16;\n\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IZirconEnergy.sol\";\nimport \"./interfaces/IUniswapV2ERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"../interfaces/IZirconPair.sol\";\n\ncontract ZirconEnergy is IZirconEnergy {\n\n  /*\n  Zircon Energy is the protocol-wide accumulator of revenue.\n  Each Pylon ahas an energy that works as a \"bank account\" and works as an insurance portion balance\n\n  We handle donations by dumping them into the insurance pool, spread evenly between pylons.\n\n  The insurance portion gets used by breakPiggybank, called by Pylons, to finance withdrawals, which is done by sending\n  Uni pool tokens to the Pylon (which then redeems them + handles partial/none repayment cases\n\n  How do we handle Float/Anchor tokens? TODO: Change all pylon fees to send the underlying\n  They are kept in their unwrapped form to form a cushion. When necessary they are minted (preferably both-sides) into Uni PTs\n\n  EDIT: No, we convert them to UniV2 PTs. Mostly for simplicity — can add a risk/asset management system later.\n\n\n  The insurance portion is managed through a per-Pylon insurance weighting that can be changed by an address stored for it,\n  defaulting to governance but tweakable to potentially introduce per-pool governance\n\n  returnExcess does some calculations to check max liability for Anchor (?) and returns any excess accrued to Pylon\n  TODO: More study of this\n\n  extractToken then allows governance to withdraw protocol revenue (only).\n  It should use some time lock checks (can't withdraw more than X per day)\n  and some amount checks (can't withdraw more than X [or percentage of total] in each transaction)\n\n  Also some way to make sure it can't called during a flash loan?\n  Hard to make it generalized while letting smart contracts call it.\n\n  All checks can be set by governance. Important to ensure that this doesn't brick the funds somehow.\n\n  addInsurance function can be called by governance to increase a pool's insurance share, which can be used to bail out pools by gov\n  */\n\n  using SafeMath for uint112;\n  using SafeMath for uint256;\n\n  struct Pylon {\n    address pylonAddress;\n    address pairAddress;\n    address floatToken;\n    address anchorToken;\n    uint insurancePerMille;\n    uint insuranceUni;\n    uint revenueUni;\n    uint minFee;\n    uint maxFee;\n  }\n  Pylon pylon;\n  struct PairFields {\n    address pylonFloat0; //Means that this pylon has token0 as float\n    address pylonFloat1;\n    uint revenueUni;\n  }\n  address energyFactory;\n  uint lastPtBalance; //Used to track balances and sync up in case of donations\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n  constructor() public {\n    energyFactory = msg.sender;\n  }\n\n  function initialize(address _pylon, address _pair, address _token0, address _token1, uint _insurancePerMille, uint _minFee, uint _maxFee) external {\n    require(msg.sender == energyFactory, 'Zircon: FORBIDDEN'); // sufficient check\n\n    bool isFloatToken0 = IZirconPair(_pair).token0() == _token0;\n    (address tokenA, address tokenB) = isFloatToken0 ? (_token0, _token1) : (_token1, _token0);\n    pylon = Pylon(\n      _pylon,\n      _pair,\n      tokenA,\n      tokenB,\n      _insurancePerMille,\n      1,\n      1,\n      _minFee, //To be given in basis points (% multiplied by 10000)\n      _maxFee\n    );\n    // Approving pylon to use anchor tokens\n    IUniswapV2ERC20(tokenB).approve(_pylon, 2^256 - 1);\n    IUniswapV2ERC20(_pair).approve(_pylon, 2^256 - 1);\n  }\n\n  // ****** HELPER FUNCTIONS *****\n  function _safeTransfer(address token, address to, uint value) private {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'Zircon Pylon: TRANSFER_FAILED');\n  }\n\n  modifier _onlyPylon() {\n    require(pylon.pylonAddress == msg.sender, \"ZE: Not Pylon\");\n    _;\n  }\n  modifier _onlyPair() {\n    require(pylon.pairAddress == msg.sender, \"ZE: Not Pylon\");\n    _;\n  }\n\n  function breakPiggybank(uint _requestedLiquidity) _onlyPylon external returns (uint returnedLiquidity) {\n    //Called by Pylon if omega is below 1. Pylon asks for X liquidity, breakPiggybank responds by depositing X or less and returning how much.\n    returnedLiquidity = pylon.insuranceUni >= _requestedLiquidity ? _requestedLiquidity : pylon.insuranceUni;\n\n    if (returnedLiquidity != 0) {\n      IUniswapV2ERC20(pylon.pairAddress).transfer(msg.sender, returnedLiquidity);\n      pylon.insuranceUni -= returnedLiquidity;\n    }\n  }\n\n  function syncFee() private {\n    uint feeLiquidity = IUniswapV2ERC20(pylon.pairAddress).balanceOf(address(this)).sub(lastPtBalance);\n    uint pylonLiquidity = IUniswapV2ERC20(pylon.pairAddress).balanceOf(pylon.pylonAddress);\n    uint ptTotalSupply = IUniswapV2ERC20(pylon.pairAddress).totalSupply();\n\n    uint float0Fee = pylonLiquidity.mul(feeLiquidity)/ptTotalSupply;\n    pylon.insuranceUni += float0Fee.mul(pylon.insurancePerMille)/1e3;\n    pylon.revenueUni += float0Fee.mul((1e3)-(pylon.insurancePerMille))/1e3;\n    _returnExcess();\n\n    uint pairLiquidity = ptTotalSupply.add(pylonLiquidity); //fundamentally impossible for this to over/sub flow\n\n    pylon.revenueUni += feeLiquidity.mul(pairLiquidity)/ptTotalSupply;\n\n    lastPtBalance = IUniswapV2ERC20(pylon.pairAddress).balanceOf(address(this));\n  }\n\n  function syncPylonFee() _onlyPylon external {\n    syncFee();\n  }\n\n  //Called by pair mintFee to register inflow. Any excess is spread evenly.\n  function syncPairFee() _onlyPair external {\n    syncFee();\n  }\n\n\n  //Returns the fee in basis points (0.01% units, needs to be divided by 10000)\n  //Uses two piece-wise parabolas. Between 0.45 and 0.55 the fee is very low (minFee).\n  //After the cutoff it uses a steeper parabola defined by a max fee at the extremes (very high, up to 15% by default).\n  //This is only used for the burn/mint async 50/50, which is effectively a swap that can cause issues when gamma is imbalanced.\n  function getFeeByGamma(uint gammaMulDecimals) external view returns (uint amount) {\n\n    uint _minFee = pylon.minFee;\n    uint _maxFee = pylon.maxFee;\n    uint _gammaHalf = 50000000000000000;\n    uint x = (gammaMulDecimals > _gammaHalf) ? (gammaMulDecimals - _gammaHalf).mul(10) : (_gammaHalf - gammaMulDecimals).mul(10);\n\n    if (gammaMulDecimals <= 450000000000000000 || gammaMulDecimals >= 550000000000000000) {\n      amount = (_maxFee.mul(x)/1e18).mul(x)/(1e18*25); //25 is a reduction factor based on the 0.45-0.55 range we're using.\n    } else {\n      amount = ((_minFee .mul(x)/1e18).mul(x)  .mul(36)/(1e18))  .add(_minFee); //Ensures minFee is the lowest value.\n    }\n\n  }\n\n  //    uint float0Liquidity;\n//    uint float1Liquidity;\n//\n//    if(_pylonFloat0 != address(0)) {\n//      float0Liquidity = IUniswapV2ERC20(_pairAddress).balanceOf(_pylonFloat0);\n//      uint float0Fee = float0Liquidity.mul(_feeLiquidity)/ptTotalSupply;\n//      Pylon storage pylonRef = pylonAccounts[_pylonFloat0]; //Storage makes this a mutable reference vs. copying with Memory\n//      uint _insurancePerMille = pylonRef.insurancePerMille;\n//\n//      pylonRef.insuranceUni += float0Fee.mul(_insurancePerMille)/1000;\n//      pylonRef.revenueUni += float0Fee.mul(1000 - _insurancePerMille)/1000;\n//      _returnExcess(_pylonFloat0);\n//    }\n//\n//    if (_pylonFloat1 != address(0)) {\n//      float1Liquidity = IUniswapV2ERC20(_pairAddress).balanceOf(_pylonFloat1);\n//\n//      uint float1Fee = float1Liquidity.mul(_feeLiquidity)/ptTotalSupply;\n//      Pylon storage pylonRef = pylonAccounts[_pylonFloat1]; //Storage makes this a mutable reference vs. copying with Memory\n//      uint _insurancePerMille = pylonRef.insurancePerMille;\n//\n//      pylonRef.insuranceUni += float1Fee.mul(_insurancePerMille)/1000;\n//      pylonRef.revenueUni += float1Fee.mul(1000 - _insurancePerMille)/1000;\n//      _returnExcess(_pylonFloat1);\n//    }\n\n\n\n  //Function called periodically to check if the reserves are too large, returns them back to pylon if they are\n  function _returnExcess() private {\n\n    //Under an LP only model there is no \"excess\". You may need to cover 100% of the pool's worth\n    //But if it is over 100% (maybe due to heavy outflows) this function returns funds to Pylon LPs.\n    //Called by syncFee\n\n    //TODO: Critical to let Pylon manage uni token excesses effectively\n    //Pylon storage pylonRef = pylonAccounts[_pylonAddress];\n    uint pylonBalance = IUniswapV2ERC20(pylon.pairAddress).balanceOf(pylon.pylonAddress);\n    if(pylon.insuranceUni > pylonBalance) {\n      uint liquidity = pylon.insuranceUni - pylonBalance;\n      _safeTransfer(pylon.pairAddress, pylon.pylonAddress, liquidity);\n      pylon.insuranceUni -= liquidity;\n    }\n\n  }\n\n\n//  //TODO: Add extensive checks and limits system to the extractToken flow\n//\n//  function extractToken() external {\n//\n//  }\n//\n//\n//  function migrateState() external {\n//\n//  }\n//\n//  function setInsuranceFactor() external {\n//\n//  }\n\n\n}\n"
    },
    "contracts/energy/ZirconEnergyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.5.16;\nimport \"./ZirconEnergy.sol\";\nimport \"./ZirconEnergyRevenue.sol\";\nimport \"./interfaces/IZirconEnergyFactory.sol\";\nimport \"./interfaces/IZirconEnergyRevenue.sol\";\n\ncontract ZirconEnergyFactory is IZirconEnergyFactory{\n    mapping(address => mapping(address => address)) public getEnergy;\n    mapping(address => mapping(address => address)) public getEnergyRevenue;\n    address[] public allEnergies;\n    address[] public allEnergiesRevenue;\n\n    event EnergyCreated(address indexed pair, address indexed energy, address tokenA, address tokenB, uint);\n\n    constructor() public {}\n\n    function allEnergiesLength() external view returns (uint) {\n        return allEnergies.length;\n    }\n\n    function allEnergiesRevenueLength() external view returns (uint) {\n        return allEnergiesRevenue.length;\n    }\n\n    function energyCodeHash() external pure returns (bytes32) {\n        return keccak256(type(ZirconEnergy).creationCode);\n    }\n    function energyRevenueCodeHash() external pure returns (bytes32) {\n        return keccak256(type(ZirconEnergy).creationCode);\n    }\n\n    function energyFor(address tokenA, address pair) view internal returns (address energy) {\n        energy = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                address(this),\n                keccak256(abi.encodePacked(tokenA, pair)),\n                hex'81043c0db8282f4e470aff61021f78b5a8a006d217071feb6f144233227db70a' // init code hash\n            ))));\n    }\n\n    function pylonFor(address tokenA, address tokenB, address pair, address pylonFactory) pure internal returns (address pylon) {\n        pylon = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                pylonFactory,\n                keccak256(abi.encodePacked(tokenA, tokenB, pair)),\n                hex'dafecbd0ed75ac7fb2fb3ddfc42dbd7f1e93400a67b26df7d15e3b43dc9d9603' // init code hash\n            ))));\n    }\n\n    function createEnergyRev(address _pair, address _tokenA, address _tokenB, address _pylonFactory) external returns (address energy) {\n        require(_tokenA != _tokenB, 'ZF: IDENTICAL_ADDRESS');\n        require(_pair != address(0), 'ZE: ZERO_ADDRESS');\n        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n        require(getEnergyRevenue[token0][token1] == address(0), 'ZE: ENERGY_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(ZirconEnergyRevenue).creationCode;\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        bytes32 salt = keccak256(abi.encodePacked(_pair, token0, token1));\n        assembly {\n            energy := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        require(energy != address(0), \"Create2: Failed on deploy\");\n        address energy0 = energyFor(token0, _pair);\n        address energy1 = energyFor(token1, _pair);\n        address pylon0 = pylonFor(token0, token1, _pair, _pylonFactory);\n        address pylon1 = pylonFor(token1, token0, _pair, _pylonFactory);\n        IZirconEnergyRevenue(energy).initialize(_pair, token0, token1, energy0, energy1, pylon0, pylon1);\n        getEnergyRevenue[token0][token1] = energy;\n        allEnergiesRevenue.push(energy);\n        emit EnergyCreated(_pair, energy, token0, token1, allEnergies.length);\n    }\n\n\n    function createEnergy(address _pylon, address _pair, address _tokenA, address _tokenB) external returns (address energy) {\n        require(_tokenA != _tokenB, 'ZF: IDENTICAL_ADDRESS');\n        require(_pylon != address(0) && _pair != address(0), 'ZE: ZERO_ADDRESS');\n        require(getEnergy[_tokenA][_tokenB] == address(0), 'ZE: ENERGY_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(ZirconEnergy).creationCode;\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        bytes32 salt = keccak256(abi.encodePacked(_pair, _tokenA));\n        assembly {\n            energy := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        require(energy != address(0), \"Create2: Failed on deploy\");\n        IZirconEnergy(energy).initialize(_pylon, _pair, _tokenA, _tokenB, 100, 0, 0);\n        getEnergy[_tokenA][_tokenB] = energy;\n        allEnergies.push(energy);\n        emit EnergyCreated(_pair, energy, _tokenA, _tokenB, allEnergies.length);\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}